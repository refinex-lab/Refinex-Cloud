# 远程服务调用

该部分根据 [Spring Cloud OpenFeign 官方文档](https://docs.spring.io/spring-cloud-openfeign/reference/spring-cloud-openfeign.html)，进行微服务项目中使用 OpenFeign 的基本约定。

## 一、理解官方文档的核心思想

---

<center>Spring Cloud OpenFeign Features - Feign Inheritance Support</center>

Feign supports boilerplate apis via single-inheritance interfaces. This allows grouping common operations into convenient base interfaces.

UserService.java

```java
public interface UserService {

	@GetMapping("/users/{id}")
	User getUser(@PathVariable("id") long id);
}
```

UserResource.java

```java
@RestController
public class UserResource implements UserService {

}
```

UserClient.java

```java
@FeignClient("users")
public interface UserClient extends UserService {

}
```

> WARNING: `@FeignClient` interfaces should not be shared between server and client and annotating `@FeignClient` interfaces with `@RequestMapping` on class level is no longer supported.

---

上述官方文档的这段介绍可以拆解成三层意思理解 👇

### 1. Feign 支持接口继承（boilerplate apis）

你可以将一组通用的接口（HTTP 调用定义）抽取到一个 “基类接口” 中， 其他服务只需 extends 该接口，就能复用方法定义，减少重复。

示例如下:

```java
// 注意：这里不需要 @RestController 或 @FeignClient 注解，只是定义 HTTP 调用接口契约
public interface UserService { // 1. 定义服务提供方的 HTTP 调用接口
    
    // 2. 定义 HTTP 调用接口的方法，包括路径、参数、返回值等
    @GetMapping("/users/{id}")
    User getUser(@PathVariable("id") long id);
}
```

这个接口只定义 **API契约（Contract）**，不关心调用方式（Feign）还是实现方式（Controller）。

### 2. 服务提供方直接实现接口

服务提供方直接实现 (implements) 该接口，这样可以保证 **Controller 层与远程调用定义严格一致**：

```java
@RestController // 1. 标注为 RESTful 控制器
public class UserResource implements UserService { // 2. 实现服务提供方定义的接口
    
    // 3. 实现接口中的方法，处理 HTTP 请求，不需要再重复编写注解、路径
    @Override
    public User getUser(long id) {
        return userRepository.findById(id);
    }
}
```

这样服务提供方无需再重复编写注解、路径，自动保持一致性。

### 3. 客户端通过 FeignClient 继承接口实现远程调用

Feign 客户端通过继承 (extends) 同一个接口进行声明：

```java
@FeignClient("user-service") // 1. 注册到 Nacos 的服务提供方实例名
public interface UserClient extends UserService { // 2. 继承服务提供方定义的接口
    // 3. 服务调用方只需要注入此接口，即可通过 Feign 调用服务提供方的方法
}
```

> ⚠️ **官方的警告重点：**
> 
> “`@FeignClient` interfaces should not be shared between server and client and annotating `@FeignClient` interfaces with `@RequestMapping` on class level is no longer supported.”
> 
> 意思是：
> 1. **不要将 `@FeignClient` 接口直接在服务提供方与调用方共享**（例如放到同一个公共模块）；
> 2. **不要在 Feign 接口上加类级别的 `@RequestMapping`**（路径统一应由服务提供方的 Controller 或契约接口定义）。

## 二、官方推荐的分层设计理念

> 简言之：**契约（API 定义）独立成模块，调用方与提供方各自引用该契约**。

这种结构称为 “**API 契约分离（Contract-first）**” 设计模式。

基于官方推荐，本项目的模块结构推荐如下:

```text
refinex-cloud/
│
├── refinex-api/                      ← 公共契约接口模块（只定义接口，不加 @FeignClient）
│   └── refinex-api-platform/         ← 平台相关的 API 契约模块
│       ├── cn.refinex.client/        ← 接口契约统一约定放在 client 包下
│       │   └── user/                 ← 模块级别的包，用于组织用户相关的 API 契约
│       │       ├── UserService.java  ← 通用API接口定义
│       │       └── dto/              ← 数据传输对象（DTO）包，用于定义请求参数、响应结果等
│       │           └── UserDTO.java
│       └── ...
│
├── refinex-platform/                 ← 服务提供方
│   └── cn.refinex.platform/
│       ├── controller/               ← 控制器包，用于处理 HTTP 请求
│       │   └── UserController.java   ← 实现契约层的 UserService 接口
│       ├── service/
│       └── repository/
│
├── refinex-auth/                     ← 服务调用方（Feign 客户端）
│   └── cn.refinex.auth/
│       ├── feign/                    ← Feign 客户端包，用于定义远程调用接口，继承服务提供方定义的接口
│       │   └── UserFeignClient.java  ← extends UserService
│       ├── service/
│       └── controller/
│
└── refinex-gateway/
```

## 三、包路径与命名规范建议

### 3.1 通用 OpenFeign 接口层模块（契约模块）

模块名建议： refinex-api-<service-name>

包命名建议：

```java
cn.refinex.api.[业务域].client   ← 存放API接口
cn.refinex.api.[业务域].dto      ← 存放DTO/VO
cn.refinex.api.[业务域].enums    ← 存放枚举
```

接口层模块可以引入 Knife4j 相关依赖, 用于生成 Swagger 文档和参数校验依赖即可:

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-openapi3-jakarta-spring-boot-starter</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
    <optional>true</optional>
</dependency>
```

示例：

```java
package cn.refinex.api.user.client;

public interface UserService {
    @GetMapping("/users/{id}")
    UserDTO getUser(@PathVariable("id") Long id);
}
```

> 注意：
> 1. 不包含 `@FeignClient` 注解
> 2. 不包含 `@RestController` 注解
> 3. 仅定义 API 契约与数据模型

Swagger/Knife4j 聚合时可直接基于契约接口生成统一文档, 例如在上面的接口上继续补充文档注解:

```java
package cn.refinex.api.user.client;

@Tag(name = "用户服务")
public interface UserService {
    
    @GetMapping("/users/{id}")
    @Operation(summary = "根据ID查询用户")
    @Parameter(description = "用户ID", required = true)
    UserDTO getUser(@PathVariable("id") Long id);
}
```

参数校验（`@Valid`, `@NotNull` 等）建议仅在接口层编写，服务实现方无需重复编写。例如：

```java
package cn.refinex.api.user.client;

@Validated
@Tag(name = "用户服务")
public interface UserService {
    
    @GetMapping("/users/{id}")
    @Operation(summary = "根据ID查询用户")
    @Parameter(description = "用户ID", required = true)
    UserDTO getUser(@PathVariable("id") @NotNull(message = "用户ID不能为空") Long id);
}
```

### 3.2 服务提供方模块（Provider）

模块名建议： refinex-<service-name>

包命名建议：

```java
cn.refinex.<service-name>.controller    ← 实现接口（Controller）
cn.refinex.<service-name>.service       ← 业务逻辑
cn.refinex.<service-name>.repository    ← 数据访问层
```

服务提供方 POM XML 依赖API契约层：

```xml
<dependency>
    <groupId>cn.refinex</groupId>
    <artifactId>refinex-api-platform</artifactId>
</dependency>
```

示例：

```java
package cn.refinex.platform.controller;

import cn.refinex.api.platform.client.UserService;

@RestController
public class UserController implements UserService {

    @Override
    public UserDTO getUser(Long id) {
        // 实际业务逻辑
        return userMapper.toDTO(userRepository.findById(id));
    }
}
```

> 注意：
> 1. 实现接口，保持契约一致
> 2. 不需要重复写 @GetMapping、@PathVariable 等注解，保持与契约一致
> 3. 可通过 Swagger 自动生成文档

### 3.3 服务调用方模块（Consumer）

模块名建议： refinex-<service-name>

包命名建议：

```java
cn.refinex.<service-name>.feign      ← Feign 客户端包，用于定义远程调用接口，继承服务提供方定义的接口
cn.refinex.<service-name>.service    ← 业务逻辑
cn.refinex.<service-name>.controller ← 控制器包，用于处理 HTTP 请求
```

服务调用方 POM XML 依赖API契约层和 OpenFeign：

```xml
<dependency>
    <groupId>cn.refinex</groupId>
    <artifactId>refinex-api-platform</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

示例：

```java
package cn.refinex.auth.feign;

import cn.refinex.api.platform.client.UserService;
import org.springframework.cloud.openfeign.FeignClient;

@FeignClient(name = "refinex-platform")
public interface UserFeignClient extends UserService {
}
```

> 注意:
> 1. 继承 UserService 契约接口
> 2. FeignClient 只出现在调用方
> 3. 与服务名绑定（通过注册中心发现）

## 总结

| 层级      | 模块            | 是否含Feign注解 | 是否含Controller注解 | 职责      |
| ------- |---------------| ---------- | --------------- | ------- |
| API 契约层 | `refinex-api-xxx` | ❌ 否        | ❌ 否             | 定义接口与模型 |
| 提供方     | `refinex-xxx` | ❌ 否        | ✅ 是             | 实现API接口 |
| 调用方     | `refinex-xxx` | ✅ 是        | ❌ 否             | 声明远程调用  |
